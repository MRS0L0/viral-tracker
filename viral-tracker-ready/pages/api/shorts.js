import axios from 'axios'
const YT = 'https://www.googleapis.com/youtube/v3'
function parseISO8601Duration(dur){ const m = dur && dur.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/); if(!m) return 0; const hh=parseInt(m[1]||0), mm=parseInt(m[2]||0), ss=parseInt(m[3]||0); return hh*3600+mm*60+ss }
export default async function handler(req,res){ try{ const API_KEY=process.env.YOUTUBE_API_KEY; if(!API_KEY) return res.status(500).json({error:'Missing YOUTUBE_API_KEY env var'}); const days=parseInt(req.query.days||'7'), maxResults=Math.min(parseInt(req.query.maxResults||'20'),50), publishedAfter=new Date(Date.now()-days*24*60*60*1000).toISOString(); const sresp=await axios.get(`${YT}/search`,{ params:{ key:API_KEY, part:'snippet', type:'video', order:'viewCount', publishedAfter, maxResults:50, videoDuration:'short' } }); const videoIds=sresp.data.items.map(it=>it.id.videoId).filter(Boolean).join(','); if(!videoIds) return res.json({items:[],channels:[],trending:[]}); const vresp=await axios.get(`${YT}/videos`,{ params:{ key:API_KEY, part:'snippet,contentDetails,statistics', id:videoIds, maxResults:50 } }); const items=vresp.data.items.map(v=>{ const sec=parseISO8601Duration(v.contentDetails.duration||''); return { id:v.id, title:v.snippet.title, channelId:v.snippet.channelId, channelTitle:v.snippet.channelTitle, thumbnails:v.snippet.thumbnails, publishedAt:v.snippet.publishedAt, durationSec:sec, views:parseInt(v.statistics.viewCount||'0'), url:`https://www.youtube.com/watch?v=${v.id}` } }).filter(x=>x.durationSec<=60 && x.views>1000).sort((a,b)=>b.views-a.views).slice(0,maxResults); const allTitles=items.map(i=>i.title.toLowerCase()).join(' '); const stop=new Set(['the','and','a','to','in','of','for','with','on','that','this','is','it','be','by','you','your','we','our','new','shorts','short']); const words=allTitles.match(/[a-z0-9]+/g)||[]; const freq={}; for(const w of words){ if(w.length<3) continue; if(stop.has(w)) continue; freq[w]=(freq[w]||0)+1 } const trending=Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,8).map(([w,c])=>({word:w,count:c})); const channelAgg={}; const now=Date.now(); for(const it of items){ const hours=Math.max(1,(now-new Date(it.publishedAt).getTime())/(1000*60*60)); const velocity=it.views/hours; if(!channelAgg[it.channelId]) channelAgg[it.channelId]={ channelId:it.channelId, channelTitle:it.channelTitle, totalViews:0, videoCount:0, avgVelocity:0, latestVideo:it }; channelAgg[it.channelId].totalViews+=it.views; channelAgg[it.channelId].videoCount+=1; channelAgg[it.channelId].avgVelocity+=velocity; if(new Date(it.publishedAt)>new Date(channelAgg[it.channelId].latestVideo.publishedAt)) channelAgg[it.channelId].latestVideo=it } const channels=Object.values(channelAgg).map(c=>{ c.avgVelocity=Math.round(c.avgVelocity/c.videoCount); return c }).sort((a,b)=>b.avgVelocity-a.avgVelocity).slice(0,10); res.setHeader('Cache-Control','s-maxage=60, stale-while-revalidate=300'); return res.json({items,channels,trending}); }catch(err){ console.error(err.message||err); return res.status(500).json({error:err.message||'unknown'}) } }
